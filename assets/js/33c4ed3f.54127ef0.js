"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[284],{7128:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>c});var r=t(4848),o=t(8453);const s={toc_min_heading_level:2,toc_max_heading_level:5,sidebar_position:2,title:"Source Development/Tutorial"},i=void 0,a={id:"development/dev-source",title:"Source Development/Tutorial",description:"This document will provide a step-by-step guide for creating a (trivial) new Source in MS alongside describing what aspects of the Source need to be implemented based on the service you use. Before using this document you should review Common Development.",source:"@site/docs/development/dev-source.md",sourceDirName:"development",slug:"/development/dev-source",permalink:"/multi-scrobbler/docs/development/dev-source",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/development/dev-source.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{toc_min_heading_level:2,toc_max_heading_level:5,sidebar_position:2,title:"Source Development/Tutorial"},sidebar:"tutorialSidebar",previous:{title:"Common Development",permalink:"/multi-scrobbler/docs/development/dev-common"},next:{title:"Client Development/Tutorial",permalink:"/multi-scrobbler/docs/development/dev-client"}},l={},c=[{value:"Scenario",id:"scenario",level:2},{value:"Minimal Implementation",id:"minimal-implementation",level:2},{value:"Define and Implement Config",id:"define-and-implement-config",level:3},{value:"Create CoolPlayer Source",id:"create-coolplayer-source",level:3},{value:"Initialize Source from Config",id:"initialize-source-from-config",level:3},{value:"Implement Play Object Transform",id:"implement-play-object-transform",level:3},{value:"Implement Stages",id:"implement-stages",level:3},{value:"Build Data",id:"build-data",level:4},{value:"Check Connection",id:"check-connection",level:4},{value:"Test Auth",id:"test-auth",level:4},{value:"Implement Polling",id:"implement-polling",level:3},{value:"Further Implementation",id:"further-implementation",level:2},{value:"Backlog",id:"backlog",level:3},{value:"Other Source Types",id:"other-source-types",level:3},{value:"Music History Source",id:"music-history-source",level:4},{value:"Non-Polling Source",id:"non-polling-source",level:4},{value:"Basic Source",id:"basic-source",level:4},{value:"Discovery",id:"discovery",level:5},{value:"Scrobbling",id:"scrobbling",level:5}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",h5:"h5",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["This document will provide a step-by-step guide for creating a (trivial) new Source in MS alongside describing what aspects of the Source need to be implemented based on the service you use. Before using this document you should review ",(0,r.jsx)(n.a,{href:"/multi-scrobbler/docs/development/dev-common#common-development",children:"Common Development"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"scenario",children:"Scenario"}),"\n",(0,r.jsxs)(n.p,{children:["You are the developer of a fancy, new self-hosted web-based media player called ",(0,r.jsx)(n.strong,{children:"Cool Player."})," Cool Player has a slick interface and many bells and whistles, but most importantly it has an API. The API:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Has an unauthenticated health endpoint at ",(0,r.jsx)(n.code,{children:"/api/health"})," that returns ",(0,r.jsx)(n.code,{children:"200"})," if the service is running properly"]}),"\n",(0,r.jsxs)(n.li,{children:["Has authenticated endpoints that require a user-generated token in the header ",(0,r.jsx)(n.code,{children:"Authorization MY_TOKEN"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Has a ",(0,r.jsx)(n.code,{children:"/api/recent"})," endpoint that lists recently played tracks with a timestamp"]}),"\n",(0,r.jsxs)(n.li,{children:["Has a ",(0,r.jsx)(n.code,{children:"/api/now-playing"})," endpoint that returns information about the state of the player like current track, player position in the track, etc..."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Cool Player is by default accessed on port ",(0,r.jsx)(n.code,{children:"6969"})]}),"\n",(0,r.jsxs)(n.li,{children:["Your personal instance of Cool Player is hosted at ",(0,r.jsx)(n.code,{children:"http://192.168.0.100:6969"})," and the api is accessed at ",(0,r.jsx)(n.code,{children:"http://192.168.0.100:6969/api"})]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Because there is an API that MS can actively read this will be a ",(0,r.jsx)(n.strong,{children:"polling"})," Source where MS sends requests to Cool Player to get scrobble information -- as opposed to an ",(0,r.jsx)(n.strong,{children:"ingress"})," Source like Jellyfin/Plex that uses webhooks from the service to send data to MS."]}),"\n",(0,r.jsx)(n.h2,{id:"minimal-implementation",children:"Minimal Implementation"}),"\n",(0,r.jsx)(n.h3,{id:"define-and-implement-config",children:"Define and Implement Config"}),"\n",(0,r.jsxs)(n.p,{children:["We will create a new config interface for Cool Player using the ",(0,r.jsx)(n.a,{href:"/multi-scrobbler/docs/development/dev-common#config",children:"Common Config"})," and tell MS it is a valid config that can be used."]}),"\n",(0,r.jsx)(n.p,{children:"Create a new file for your config:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="/src/backend/common/infrastructure/config/source/coolplayer.ts"',children:"import { PollingOptions } from \"../common.js\";\nimport { CommonSourceConfig, CommonSourceData } from \"./index.js\";\n\n// all of the required data for the Build Data and Test Auth stages (from Common Development docs)\n// should go here\nexport interface CoolPlayerSourceData extends CommonSourceData, PollingOptions {\n// remember to annotation your properties!\n\n  /**\n   * The user-generated token for Cool Player auth created in Cool Player -> Settings -> User -> Tokens\n   *\n   * @example f243331e-cf5b-49d7-846b-0845bdc965b4\n   * */\n  token: string\n  /**\n   * The host and port where Cool Player is hosted\n   *\n   * @example http://192.168.0.100:6969\n   * */\n  baseUrl: string\n}\n\nexport interface CoolPlayerSourceConfig extends CommonSourceConfig {\n  data: CoolPlayerSourceData\n}\n\nexport interface CoolPlayerSourceAIOConfig extends CoolPlayerSourceConfig {\n  // when using the all-in-one 'config.json' this is how users will identify this source\n  type: 'coolplayer'\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Add the new interface to the list of valid interfaces for sources:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="src/backend/common/infrastructure/config/source/sources.ts"',children:'import { ChromecastSourceAIOConfig, ChromecastSourceConfig } from "./chromecast.js";\n// ...\n// highlight-next-line\nimport { CoolPlayerSourceAIOConfig, CoolPlayerSourceConfig } from "./coolplayer.js";\n\nexport type SourceConfig =\n        SpotifySourceConfig\n        // ...\n        // highlight-next-line\n        | CoolPlayerSourceConfig;\n\nexport type SourceAIOConfig =\n        SpotifySourceAIOConfig\n        // ...\n        // highlight-next-line\n        | CoolPlayerSourceAIOConfig;\n'})}),"\n",(0,r.jsx)(n.p,{children:"Finally, add the source type identifier to the list of valid identifiers"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="src/backend/common/infrastructure/Atomic.ts"',children:"export type SourceType =\n    'spotify'\n    // ...\n    // highlight-next-line\n    | 'coolplayer';\n\nexport const sourceTypes: SourceType[] = [\n    'spotify',\n    // ...\n    // highlight-next-line\n    'coolplayer'\n];\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Now we will create a new Source inheriting from ",(0,r.jsx)(n.a,{href:"/multi-scrobbler/docs/development/dev-common#concrete-class",children:(0,r.jsx)(n.code,{children:"AbstractComponent"})})," that:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"accepts our config interface"}),"\n",(0,r.jsxs)(n.li,{children:["implements a function to transform CoolPlayer's track data into a ",(0,r.jsx)(n.a,{href:"/multi-scrobbler/docs/development/dev-common#play-object",children:(0,r.jsx)(n.strong,{children:"PlayObject"})})]}),"\n",(0,r.jsxs)(n.li,{children:["implements required ",(0,r.jsx)(n.a,{href:"/multi-scrobbler/docs/development/dev-common#stages",children:"stages"})]}),"\n",(0,r.jsx)(n.li,{children:"implements required methods to current player state and/or now playing track"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"create-coolplayer-source",children:"Create CoolPlayer Source"}),"\n",(0,r.jsxs)(n.p,{children:["First we create a new Source called ",(0,r.jsx)(n.code,{children:"CoolPlayerSource"})," and setup our constructor to accept the config and ",(0,r.jsx)(n.a,{href:"/multi-scrobbler/docs/development/dev-common#stage-test-auth",children:"specify Auth behavior."})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="src/backend/sources/SpotifySource.ts"',children:'import { CoolPlayerSourceConfig } from "../common/infrastructure/config/source/coolplayer.js";\nimport MemorySource from "./MemorySource.js";\nimport {\n  InternalConfig,\n} from "../common/infrastructure/Atomic.js";\n\n// MemorySource is the base class used for polling-type Sources\nexport default class CoolPlayerSource extends MemorySource {\n\n  // type hints for TS to know what the base class config looks like\n  declare config: CoolPlayerSourceConfig;\n\n  constructor(name: any, config: CoolPlayerSourceConfig, internal: InternalConfig, emitter: EventEmitter) {\n    super(\'coolplayer\', name, config, internal, emitter);\n\n    // Cool Player required authentication\n    this.requiresAuth = true;\n    // but does not require user interaction for auth to work\n    this.requiresAuthInteraction = false;\n    // tells MS this is a Source that can be activity monitored through API\n    this.canPoll = true;\n  }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"initialize-source-from-config",children:"Initialize Source from Config"}),"\n",(0,r.jsxs)(n.p,{children:["When MS starts it reads all configs and determines which Source to build based on the configs found. We need to tell it to build a ",(0,r.jsx)(n.code,{children:"CoolPlayerSource"})," when a ",(0,r.jsx)(n.code,{children:"coolplayer"})," config type is found."]}),"\n",(0,r.jsxs)(n.p,{children:["We modify ",(0,r.jsx)(n.code,{children:"ScrobbleSources.ts"})," to add ",(0,r.jsx)(n.code,{children:"CoolPlayerSource"})," as an option:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="src/backend/sources/ScrobbleSources.ts"',children:"// ...\nimport { CoolPlayerSource, CoolPlayerData } from \"./CoolPlayerSource.js\";\n\nexport default class ScrobbleSources {\n  // ...\n  buildSourcesFromConfig = async (additionalConfigs: ParsedConfig[] = []) => {\n    // ...\n\n    // if CoolPlayerSource should be able to be built from ENVs only \n    // then add it as a case statement here\n    for (const sourceType of sourceTypes) {\n      switch (sourceType) {\n              // ...\n        case 'musikcube':\n          // ...\n          break;\n              // highlight-start\n        case 'coolplayer':\n          const cp = {\n            baseUrl: process.env.COOL_URL,\n            token: process.env.COOL_TOKEN\n          }\n          if (!Object.values(cp).every(x => x === undefined)) {\n            configs.push({\n              type: 'coolplayer',\n              name: 'unnamed',\n              source: 'ENV',\n              mode: 'single',\n              configureAs: defaultConfigureAs,\n              data: cp as CoolPlayerData\n            });\n          }\n          break;\n              // highlight-end\n        default:\n          break;\n      }\n    }\n  }\n\n  // ...\n\n  // (required) create new CoolPlayerSource if source config type is 'coolplayer'\n  addSource = async (clientConfig: ParsedConfig, defaults: SourceDefaults = {}) => {\n    // ...\n    let newSource: AbstractSource;\n    switch (type) {\n      // ...\n      case 'musikcube':\n        // ...\n        break;\n            // highlight-start\n      case 'coolplayer':\n        newSource = await new CoolPlayerSource(name, compositeConfig as CoolPlayerSourceConfig, internal, this.emitter);\n        break;\n            // highlight-end\n      default:\n        break;\n    }\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"implement-play-object-transform",children:"Implement Play Object Transform"}),"\n",(0,r.jsxs)(n.p,{children:["Now we will create a static function that is used to take the track data returned from Cool Player's API and return a standard ",(0,r.jsxs)(n.a,{href:"/multi-scrobbler/docs/development/dev-common#play-object",children:[(0,r.jsx)(n.code,{children:"PlayObject"}),"."]})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="src/backend/sources/CoolPlayerSource.ts"',children:'import dayjs from "dayjs";\nimport {\n  FormatPlayObjectOptions,\n} from "../common/infrastructure/Atomic.js";\nimport { PlayObject } from "../../core/Atomic.js";\n\nexport default class CoolPlayerSource extends MemorySource {\n  // ...\n\n  // \'obj\' should ideally be a real TS interface\n  // if CoolPlayer has a ts/js client we would use that otherwise\n  // we should build our own interfaces to represent track data from Cool Player\'s API\n  static formatPlayObj(obj: any, options: FormatPlayObjectOptions = {}): PlayObject {\n    const {\n      trackName,\n      artistName,\n      albumName,\n      duration,\n      playedAt,\n    } = obj;\n\n    return {\n      data: {\n        artists: [artistName],\n        album: albumName,\n        track: trackName,\n        // assuming seconds\n        duration,\n        // assuming playedAt is an ISO8601 timestamp\n        playDate: dayjs(playedAt)\n      },\n      meta: {\n        source: \'CoolPlayer\'\n      }\n    }\n  }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"implement-stages",children:"Implement Stages"}),"\n",(0,r.jsxs)(n.p,{children:["Next we will implement the ",(0,r.jsx)(n.a,{href:"/multi-scrobbler/docs/development/dev-common#stages",children:"Stages"})," required to get CoolPlayerSource running."]}),"\n",(0,r.jsx)(n.h4,{id:"build-data",children:"Build Data"}),"\n",(0,r.jsxs)(n.p,{children:["First we implement the ",(0,r.jsx)(n.a,{href:"/multi-scrobbler/docs/development/dev-common#stage-build-data",children:"Build Data Stage"}),". We will check that the ",(0,r.jsx)(n.code,{children:"token"})," and ",(0,r.jsx)(n.code,{children:"baseUrl"})," properties have been provided by the user. Additionally, we will parse the baseUrl and add default ports/prefix."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="src/backend/sources/CoolPlayerSource.ts"',children:"import { URL } from \"url\";\n// ...\n\nexport default class CoolPlayerSource extends MemorySource {\n\n  baseUrl!: URL;\n\n  // ...\n\n  static parseConnectionUrl(val: string) {\n    const normal = normalizeUrl(val, {removeTrailingSlash: false, normalizeProtocol: true})\n    const url = new URL(normal);\n\n    if (url.port === null || url.port === '') {\n      url.port = '6969';\n    }\n    if (url.pathname === '/') {\n      url.pathname = '/api/';\n    }\n    return url;\n  }\n\n  protected async doBuildInitData(): Promise<true | string | undefined> {\n    const {\n      token,\n      baseUrl\n    } = this.config;\n    if (token === null || token === undefined || (typeof token === 'string' && token.trim() === '')) {\n      throw new Error(`'token' must be defined`);\n    }\n\n    if (baseUrl === null || baseUrl === undefined || (typeof baseUrl === 'string' && baseUrl.trim() === '')) {\n      throw new Error(`'baseUrl' must be defined`);\n    }\n    try {\n      this.baseUrl = CoolPlayerSource.parseConnectionUrl(baseUrl);\n    } catch (e) {\n      throw new Error(`Could not parse baseUrl: ${baseUrl}`, {cause: e});\n    }\n\n    this.logger.verbose(`Config URL: ${baseUrl} => Normalized: '${this.url.toString()}'`);\n    return true;\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"check-connection",children:"Check Connection"}),"\n",(0,r.jsxs)(n.p,{children:["Second we will implement the ",(0,r.jsx)(n.a,{href:"/multi-scrobbler/docs/development/dev-common#stage-check-connection",children:"Check Connection Stage"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="src/backend/sources/CoolPlayerSource.ts"',children:"import request from 'superagent';\nimport { UpstreamError } from \"../common/errors/UpstreamError.js\";\n// ...\nexport default class CoolPlayerSource extends MemorySource {\n\n  // ...\n\n  protected async doCheckConnection(): Promise<true | string | undefined> {\n    try {\n      const resp = await request.get(`${this.baseUrl}/health`);\n      return true;\n      // if /health returned version info we could instead read response and return a string with version info for visibility to the user\n      // return `Cool Player Version: ${resp.body.version}`;\n    } catch (e) {\n      throw e;\n    }\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"test-auth",children:"Test Auth"}),"\n",(0,r.jsxs)(n.p,{children:["Finally, we will implement ",(0,r.jsx)(n.a,{href:"/multi-scrobbler/docs/development/dev-common#stage-test-auth",children:"Auth Test Stage"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="src/backend/sources/CoolPlayerSource.ts"',children:"import request from 'superagent';\nimport { UpstreamError } from \"../common/errors/UpstreamError.js\";\n// ...\nexport default class CoolPlayerSource extends MemorySource {\n\n  // ...\n\n  doAuthentication = async () => {\n    try {\n      const resp = await request\n              .get(`${this.baseUrl}/recent`)\n              .set('Authorization', `Token ${this.config.token}`);\n      return true;\n    } catch (e) {\n      // if Cool Player returned an error as json we could parse it from error body and throw new Error with the message\n      throw e;\n    }\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"implement-polling",children:"Implement Polling"}),"\n",(0,r.jsxs)(n.p,{children:["The majority of Sources MS monitors primarily operate as a source of truth for a ",(0,r.jsx)(n.strong,{children:"music player"})," rather than a ",(0,r.jsx)(n.strong,{children:"played music history."})," Only Listenbrainz and Last.fm operate as a source of music history."]}),"\n",(0,r.jsxs)(n.p,{children:["To this end, MS implements a ",(0,r.jsx)(n.a,{href:"https://www.freecodecamp.org/news/state-machines-basics-of-computer-science-d42855debc66/",children:"state machine"}),' that emulates the behavior of a music player in order to keep track of when a song you are listening to should be scrobbled. It does this by monitoring the "currently playing" track reported by a Source\'s service, with varying degrees of accuracy depending on what information is returned from the service. The state machine is implemented in ',(0,r.jsx)(n.code,{children:"MemorySource"})," which our ",(0,r.jsx)(n.code,{children:"CoolPlayerSource"})," inherits from."]}),"\n",(0,r.jsxs)(n.p,{children:["For a polling Source to work properly we need to implement a function, ",(0,r.jsx)(n.a,{href:"https://github.com/FoxxMD/multi-scrobbler/blob/master/src/backend/sources/AbstractSource.ts#L92",children:(0,r.jsx)(n.code,{children:"getRecentlyPlayed"})}),', that returns PlayObjects that are "newly" played. These are then checked against previously "discovered" plays and their timestamp to determine if they should be surfaced to Clients to scrobble.']}),"\n",(0,r.jsxs)(n.p,{children:["To take advantage of the ",(0,r.jsx)(n.code,{children:"MemorySource"})," state machine we will additionally use ",(0,r.jsx)(n.a,{href:"https://github.com/FoxxMD/multi-scrobbler/blob/master/src/backend/sources/MemorySource.ts#L113",children:(0,r.jsx)(n.code,{children:"processRecentPlays"})})," from ",(0,r.jsx)(n.code,{children:"MemorySource"})," inside ",(0,r.jsx)(n.code,{children:"getRecentlyPlayed"}),". We pass track and/or player state returned from the Source service to ",(0,r.jsx)(n.code,{children:"processRecentPlayers"}),". It then takes care of deriving Source player state based on how this data changes over time. The advantage to using ",(0,r.jsx)(n.code,{children:"processRecentPlays"})," is that our Source service does not necessarily need to pass any player information -- as long as the track info has a ",(0,r.jsx)(n.strong,{children:"duration"})," we can more-or-less determine if it has been played long enough to scrobble."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="src/backend/sources/CoolPlayerSource.ts"',children:"import request from 'superagent';\nimport {\n  SourceData,\n  PlayerStateData,\n  SINGLE_USER_PLATFORM_ID\n} from \"../common/infrastructure/Atomic.js\";\n// ...\nexport default class CoolPlayerSource extends MemorySource {\n\n  // ...\n\n  protected async getRecentlyPlayed(options: RecentlyPlayedOptions = {}): Promise<PlayObject[]> {\n    const plays: SourceData[] = [];\n    try {\n      // currently playing tracks/player state data\n      const resp = await request\n              .get(`${this.baseUrl}/now-playing`)\n              .set('Authorization', `Token ${this.config.token}`);\n      const {\n        body: {\n          playerState, // 'playing' or 'stopped' or 'paused'...\n          position, // number of seconds into the track IE at position 48 -> ( 0:48/3:56 in player UI )\n          play: { /* track data */}\n        }\n      } = resp;\n\n      // transform into standard player state data\n      const playerData: PlayerStateData = {\n        platformId: SINGLE_USER_PLATFORM_ID,\n        play: CoolPlayerSource.formatPlayObj(play),\n        position\n      };\n\n      // if Cool Player does return player state we can also push a regular PlayObject to this list\n      plays.push(playerData);\n    } catch (e) {\n      throw e;\n    }\n\n    // process player state through state machine\n    // if the track changes or player state changes\n    // and currently played track has been listened to long enough to be scrobbled it will return in newPlays\n    const newPlays = this.processRecentPlays(plays);\n\n    // finally, we return new plays and MS checks to see if they have been previously seen \n    // before signalling to Clients that they can be scrobbled\n    return newPlays;\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Congratulations! Your ",(0,r.jsx)(n.code,{children:"CoolPlayerSource"})," has been minimally implemented and can now be used in multi-scrobbler."]}),"\n",(0,r.jsx)(n.h2,{id:"further-implementation",children:"Further Implementation"}),"\n",(0,r.jsx)(n.h3,{id:"backlog",children:"Backlog"}),"\n",(0,r.jsx)(n.p,{children:'To have your Source try to scrobble "missed" tracks when MS starts up the Source\'s service must be able to provide:'}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"track information"}),"\n",(0,r.jsx)(n.li,{children:"timestamp of when the track was played"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["In your Source implement ",(0,r.jsx)(n.a,{href:"https://github.com/FoxxMD/multi-scrobbler/blob/master/src/backend/sources/AbstractSource.ts#L235",children:(0,r.jsx)(n.code,{children:"getBackloggedPlays"})})," and set setting in constructor indicating it has backlogging capabilities:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="src/backend/sources/CoolPlayerSource.ts"',children:"import request from 'superagent';\nimport {\n  PlayObject,\n} from \"../common/infrastructure/Atomic.js\";\n// ...\nexport default class CoolPlayerSource extends MemorySource {\n\n  constructor(/* ... */) {\n    super(/* ... */);\n    // ...\n\n    // tell MS it should try to get backlogged tracks on startup\n    this.canBacklog = true;\n  }\n\n  // ...\n\n  protected getBackloggedPlays = async (options: RecentlyPlayedOptions): Promise<PlayObject[]> => {\n    try {\n      const resp = await request\n              .get(`${this.baseUrl}/recent`)\n              .set('Authorization', `Token ${this.config.token}`);\n\n      // assuming list from body looks like track info returned in \n      // \"Implement Play Object Transform\" section\n      const {\n        body = []\n      } = resp;\n\n      return body.map(x => CoolPlayerSource.formatPlayObj(x));\n    } catch (e) {\n      throw new Error('Error occurred while getting recently played', {cause: e});\n    }\n\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"other-source-types",children:"Other Source Types"}),"\n",(0,r.jsx)(n.p,{children:"There are some scenarios where polling and/or state machine is not the right tool to handle determining if incoming data should be scrobbled:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The Source service handles scrobble threshold internally, the data being received should always be scrobbled (WebScrobbler, Plex, Tautulli, Listenbrainz, Last.fm)"}),"\n",(0,r.jsx)(n.li,{children:"You prefer to handle the scrobble determination yourself"}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"music-history-source",children:"Music History Source"}),"\n",(0,r.jsxs)(n.p,{children:["If the Source is still polling but the track returned should always be scrobbled if not already seen IE the Source service is a ",(0,r.jsx)(n.strong,{children:"music history source"})," (Listenbrainz, Last.fm), rather than a music player, then simply indicate to MS the source of truth type by setting it in the constructor. The state machine will always return a track if it is new and not seen, regardless of how recently it was seen:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="src/backend/sources/CoolPlayerSource.ts"',children:'import { SOURCE_SOT } from "../../core/Atomic.js";\n// ...\nexport default class CoolPlayerSource extends MemorySource {\n\n  constructor(/* ... */) {\n    super(/* ... */);\n    // ...\n\n    // tell MS it should immediately scrobble any new, unseen tracks from the upstream service\n    this.playerSourceOfTruth = SOURCE_SOT.HISTORY;\n  }\n}\n'})}),"\n",(0,r.jsx)(n.h4,{id:"non-polling-source",children:"Non-Polling Source"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Ingress"})," Sources (like Plex, Tautulli, Webscrobbler, Jellyfin) do not having a polling mechanism because the upstream service contacts MS when there is an event, rather than MS contacting the upstream service."]}),"\n",(0,r.jsxs)(n.p,{children:["For these Sources you will need to implement endpoints in ",(0,r.jsx)(n.code,{children:"src/service/api.ts"})," and corresponding files. See the existing Sources in the project as references for how to do this."]}),"\n",(0,r.jsxs)(n.p,{children:["You may still wish to use the state machine ",(0,r.jsx)(n.code,{children:"MemorySource"}),' (like Jellyfin) if the events received are not "scrobble" events but instead of implementing ',(0,r.jsx)(n.code,{children:"getRecentlyPlayed"})," you will implement your own function in your Source class, like ",(0,r.jsx)(n.code,{children:"handle()"}),", that receives data and then uses ",(0,r.jsx)(n.code,{children:"processRecentPlays"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"After new plays have been determined see the next section for how to scrobble..."}),"\n",(0,r.jsx)(n.h4,{id:"basic-source",children:"Basic Source"}),"\n",(0,r.jsxs)(n.p,{children:["At the core of a Source that implements ",(0,r.jsx)(n.code,{children:"AbstractSource"}),"'s functionality is the ability to ",(0,r.jsx)(n.strong,{children:"Discover"})," and ",(0,r.jsx)(n.strong,{children:"Scrobble"})," plays."]}),"\n",(0,r.jsxs)(n.p,{children:["These functions are not seen in the MVP ",(0,r.jsx)(n.code,{children:"CoolPlayerSource"})," because they are automatically done by the polling functionality after being returned from ",(0,r.jsx)(n.code,{children:"getRecentlyPlayed"}),"."]}),"\n",(0,r.jsx)(n.h5,{id:"discovery",children:"Discovery"}),"\n",(0,r.jsxs)(n.p,{children:['A Source keeps track of all the "plays" that are determined to be valid for scrobbling. When a play is valid it is checked to see if it has already been "discovered" by comparing the track info and timestamp of the play against already discovered plays. This prevents duplicate scrobbling by using the Source\'s own data and simplifies scrobbling for Sources by allowing your implementation to "always" ingest track data without having to worry about whether its new or not -- ',(0,r.jsx)(n.code,{children:"AbstractSource"})," and ",(0,r.jsx)(n.code,{children:"discover()"})," will take care of that for you."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="src/backend/sources/MyBasicSource.ts"',children:'export default class MyBasicSource extends AbstractSource {\n  handle(somePlay: PlayObject) {\n    // if the track is "new" and not seen before it is returned in the discovered list\n    // we then know it is OK to be sent to Clients for scrobbling\n    const discovered: PlayObject[] = this.discover([somePlay]);\n  }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:'This additionally will be surfaced to the user in the Dashboard in the "Tracks Discovered" page.'}),"\n",(0,r.jsx)(n.h5,{id:"scrobbling",children:"Scrobbling"}),"\n",(0,r.jsx)(n.p,{children:"After a play is verified to be discovered we can then scrobble it. This will emit the plays to the ScrobbleClients service which then disseminates the play to all Clients that were configured to listen in the Source's config."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="src/backend/sources/MyBasicSource.ts"',children:"export default class MyBasicSourceSource extends AbstractSource {\n  handle(somePlay: PlayObject) {\n    const discovered: PlayObject[] = this.discover([somePlay]);\n    // emit plays that can be scrobbled by clients\n    this.scrobble(discovered);\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["If your service only emits an event when a play is scrobbled you can ",(0,r.jsx)(n.em,{children:"technically"})," skip using ",(0,r.jsx)(n.code,{children:"discover()"})," but it is good practice to use it unless you have a very good reason not to."]}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsxs)(n.p,{children:["Using ",(0,r.jsx)(n.code,{children:"scrobble()"}),' does not guarantee a track is actually scrobbled! The Scrobble Clients also check the play against their own "recently scrobbled" list to prevent duplicates.']})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var r=t(6540);const o={},s=r.createContext(o);function i(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);